#!/bin/sh

# Oyster - Embedded shell based static blog generator

# The MIT License (MIT)
#
# Copyright (c) 2016 Sunaina Pai
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


VERSION=0.1.0-DEV
AUTHOR="Sunaina Pai"
COPYRIGHT="Copyright (c) 2016 $AUTHOR"
SUPPORT_URL="https://github.com/sunainapai/oyster/issues"
NAME=${0##*/}


NL="
"


# CORE FUNCTIONS
# ==============
# The following core functions form the core API that may be invoked
# from the site configuration script (site.sh by default) to render a
# blog or website.


# DESCRIPTION
#   Read file, find and execute shell commands embedded in text and
#   replace each command with the standard output written by the
#   command. If the file uses a template, render it recursively such
#   that the 'content' command is replaced with the output of the file.
#   The output generated due to the last template processed is the
#   output of this function.
#
#   Limitation: This function may only be called from the site
#   configuration script. If a text being rendered invokes the render
#   function within embedded shell code, the behaviour is undefined.
#   This function must not be called from embedded shell code.
#
# OPERANDS
#   1. File to be rendered. (Optional)
#
# STDIN
#   The standard input is used as file if no file operand is specified.
#
# STDOUT
#   The rendered file is written to the standard output.
#
# STDERR
#   Any errors encountered while rendering are written to the standard
#   error.
#
# EXIT STATUS
#   0 If the file is rendered successfully.
#   1 If the rendering fails.
render()
{
    if [ -n "$1" ]
    then
        _eval_embedded_shell < "$1" > /tmp/content.html
    else
        _eval_embedded_shell <<eof > /tmp/content.html
$(cat)
eof
    fi

    _content=$(cat /tmp/content.html)
    while [ -n "$_template" ]
    do
        _template_file=$_template
        # Store the file name to execute, unset _template so that it can
        # be defined afresh in next execution. If the next execution
        # does not define a template, _template variable remains unset
        # which ends the loop.
        unset _template
        _eval_embedded_shell < "$_template_file" > /tmp/content.html
        _content=$(cat /tmp/content.html)
    done

    # Introduce new line at the end of file to overcome noeol.
    printf "%s\n" "$_content"

    unset _content
    unset _template_file
}


# DESCRIPTION
#   Set base template for a content file being rendered.
#
#   A content file is a file that invokes the 'template' command. The
#   filename specified as argument to the 'template' command is known as
#   the template file.
#
#   This function must be called with the path to the template file as
#   its argument. The path must be relative to the directory where
#   oyster is run.
#
#   Once this function is called in a content file, the template file
#   specified as the argument is considered to be the base template for
#   the content file. The files are rendered according to the following
#   algorithm.
#
#     1. The content file is rendered first.
#     2. If the content file does not invoke the 'template' function,
#        then rendering is complete. No further steps are performed.
#     3. If the content file invokes the 'template' function, then
#        the template file is rendered.
#     4. Any occurrence of the 'content' function call in the template
#        file is replaced with the rendered content file.
#     5. Now assume the template file to be content file and go to step 2.
#
#   Note that a template file itself may be a content file if it
#   invokes the 'template' command.
#
# OPERANDS
#   1. Path to the template file relative to where oyster is run.
#
# STDIN
#   Not used.
#
# STDOUT
#   Not used.
#
# STDERR
#   Not used.
#
# EXIT STATUS
#   0
template()
{
    _template=$1
}


# DESCRIPTION
#   Output rendered content file that invoked the current template file.
#
#   See the comments for the 'template' function for more details about
#   how the 'template' and 'content' functions work together.
#
# OPERANDS
#   None.
#
# STDIN
#   Not used.
#
# STDOUT
#   Not used.
#
# STDERR
#   Not used.
#
# EXIT STATUS
#   0
content()
{
    printf %s "$_content"
}


# DESCRIPTION
#   Render input text and include in the current text being rendered.
#   This function is similar to the render function with the following
#   exceptions:
#
#     1. This function may be called within embedded shell code.
#     2. This function ignores the template function call.
#
#   Therefore, this function cannot render any templates invoked within
#   embedded shell code.
#
# OPERANDS
#   1. File to be rendered. (Optional)
#
# STDIN
#   The standard input is used as file if no file operand is specified.
#
# STDOUT
#   The rendered file is written to the standard output.
#
# STDERR
#   Any errors encountered while rendering are written to the standard
#   error.
#
# EXIT STATUS
#   0 If the file is rendered successfully.
#   1 If the rendering fails.
include()
{
    if [ -n "$1" ]
    then
        _eval_embedded_shell < "$1"
    else
        _eval_embedded_shell <<eof
$(cat)
eof
    fi
}


# UTILITY FUNCTIONS
# =================
# The following utility functions form the utility API that may be
# invoked from the configuration script (site.sh by default).


# DESCRIPTION
#   Render multiple files in a directory.
#
# OPERANDS
#   1. Path to source directory containing post files.
#   2. File pattern (glob) to search for post files.
#   3. Template to use to render files in source directory.
#   4. Output directory where rendered files are written.
#
# STDIN
#   Not used.
#
# STDOUT
#   Progress details is written to the standard output.
#
# STDERR
#   Errors encountered while rendering is written to the standard error.
#
# EXIT STATUS
#   0 On success.
#   1 On failure.
render_dir()
{
    find "$1" -name "$2" |
    while read -r file
    do
        # Create directory for post's index.html.
        target_path=_site/"$4"/$(get_post_id "$file")/index.html
        mkdir -p "$(dirname "$target_path")"
        post_create_date=$(get_post_date "$file")
        echo Rendering "$file" ...
        template "$3"
        unset post_title
        render "$file" > "$target_path"
    done
}


# DESCRIPTION
#   Extract post ID from post file path.
#
#   The syntax of a file name is [date-]title.ext,
#   e.g. 2016-08-09-hello-world.html, hello-world.html, etc.
#
#   This function removes any leading directory path, date, trailing
#   extension name and returns only the title part of the filename.
#
#   Examples:
#     get_post_id /foo/bar/2016-08-09-hello-world.html => hello-world
#     get_post_id /foo/bar/hello-world.html => hello-world
#
#   Only alphanumeric characters, underscore and hyphen are supported in
#   the filename. If any other characters are specified in the filename,
#   the behaviour is unspecified.
#
#   The post ID is used as post slug in the URL of the post when the
#   posts are rendered by the render_dir function.
#
# OPERANDS
#   1. Path to post file.
#
# STDIN
#   Not used.
#
# STDOUT
#   Post ID is written to the standard output.
#
# STDERR
#   Not used.
#
# EXIT STATUS
#   0 On success.
#   1 On failure.
get_post_id()
{
    # Remove leading directory path.
    set "${1##*/}"

    # Remove leading date.
    set "${1##[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-}"

    # Remove trailing extension name.
    set "${1%%.*}"

    # Output the post ID.
    printf %s "$1"
}


# DESCRIPTION
#   Extract post date from post file path.
#
#   The filename must be in YYYY-MM-DD-title.ext format. If not, the
#   behaviour of this function is undefined.
#
#   Examples:
#     get_post_date /foo/bar/2016-08-09-hello-world.html => 2016-08-09
#     get_post_date /foo/bar/hello-world.html => Undefined behaviour
#
# OPERANDS
#   1. Path to post file.
#
# STDIN
#   Not used.
#
# STDOUT
#   Post date is written to the standard output.
#
# STDERR
#   Not used.
#
# EXIT STATUS
#   0 On success.
#   1 On failure.
get_post_date()
{
    printf %s "${1##*/}" | sed "s/.*\([0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\).*/\1/"
}


# DESCRIPTION
#   Extract post year from post file path.
#
#   The filename must be in YYYY-MM-DD-title.ext format. If not, the
#   behaviour of this function is undefined.
#
#   Examples:
#     get_post_year /foo/bar/2016-08-09-hello-world.html => 2016
#     get_post_year /foo/bar/hello-world.html => Undefined behaviour
#
# OPERANDS
#   1. Path to post file.
#
# STDIN
#   Not used.
#
# STDOUT
#   Post year is written to the standard output.
#
# STDERR
#   Not used.
#
# EXIT STATUS
#   0 On success.
#   1 On failure.
get_post_year()
{
    # Remove leading directory path.
    set "${1##*/}"

    # Remove everything except year (YYYY).
    set "${1%-[0-9][0-9]-[0-9][0-9]-*}"

    # Output the post year.
    printf %s "$1"
}


# DESCRIPTION
#   Remove HTML tags from specified text.
#
# OPERANDS
#   1. Text with HTML tags.
#
# STDIN
#   None.
#
# STDOUT
#   Post year is written to the standard output.
#
# STDERR
#   Not used.
#
# EXIT STATUS
#   0 On success.
#   1 On failure.
strip_html()
{
    sed 's/<[^>]*>//g'
}


# DESCRIPTION
#   Truncate text to the specified number of words.
#
# OPERANDS
#   1. Number of words to truncate the given text to.
#
# STDIN
#   Input text.
#
# STDOUT
#   Post year is written to the standard output.
#
# STDERR
#   Not used.
#
# EXIT STATUS
#   0 On success.
#   1 On failure.
truncate_text()
{
    # Follow each word with a space and newline.
    sed "s/$/ /" | sed "s/ / \\$NL/g" |

    # Ignore lines consisting only of whitespace and non-printable
    # characters.
    grep "[[:graph:]]" |

    # Select the specified number of lines.
    head -n "$1" |

    # Remove the newlines.
    tr -d '\n' |

    # Remove the trailing space.
    sed 's/ $//'
}


# PRIVATE FUNCTIONS
# =================
# The following private functions are not part of the API. They should
# not be invoked directly by the configuration script.


# DESCRIPTION
#   Find shell code embedded in the input text, evaluate the shell
#   commands and replace the shell code with their output.
#
#   The input text is tokenized into two kinds of text:
#
#     1. Shell code delimited with shell code tags (default: '{{' and '}}').
#     2. Static text, i.e. any text that is not shell code.
#
#   Each block of shell code is executed and the block is replaced with
#   the standard output generated the shell code.
#
# OPERANDS
#   None.
#
# STDIN
#   The standard input is used as the file to be rendered.
#
# STDOUT
#   The rendered file is written to the standard output.
#
# STDERR
#   Any errors encountered while rendering are written to the standard
#   error.
#
# EXIT STATUS
#   0 If the file is rendered successfully.
#   1 If the rendering fails.
_eval_embedded_shell()
{
    while IFS= read -r _line
    do
        # Tokenize input: For each line in the input file, place each
        # occurrence of shell code, e.g. "{{ date }}", on its own line.
        # Each output line contains a single token (i.e. static text or
        # shell code). These lines of tokens are fed to the inner while
        # loop.
        #
        # Note: The three statements below could have been written as a
        # single pipeline. But they are written as separate statements
        # to work around a kcov bug; kcov misses all lines except the
        # last one in a multiline command substitution.
        tokens=$(printf %s "$_line")
        tokens=$(printf %s "$tokens" | sed "s/{{/\\$NL{{/g")
        tokens=$(printf %s "$tokens" | sed "s/}}/}}\\$NL/g")

        # Loop over the each line of tokenized input and evaluate the
        # shell-script-tokens.
        # Set IFS to nothing, to preserve indentation, whitespaces etc.
        while IFS= read -r _token
        do
            if printf "%s" "$_token" | grep -q "^{{"
            then
                # While tokenizing, we inserted a newline before each
                # shell script token. We undo that by printing the
                # output of the evaluated shell script without any
                # preceding newline.
                _code=$(printf "%s" "$_token" | sed "s/.*{{\(.*\)}}.*/\1/")
                eval "$_code"
            else
                printf "%s" "$_token"
            fi

# Do not indent anything within here-document to workaround a yash bug
# where read command does not remove leading IFS. Ensure that input to
# read command does not contain leading IFS.
        done <<eof
$(printf %s "$tokens")
eof
        # Write a new line as we have reached the end of the original source
        # code line.
        printf "\n"
        done

    unset _code
    unset _line
    unset _token
}


# DESCRIPTION
#   Starting point of this script.
#
# OPERANDS
#   All command line arguments this script was invoked with.
#
# STDIN
#   Not used.
#
# STDOUT
#   Output of some command line arguments such as -h/--help,
#   -v/--version, etc. are written to the standard output.
#
# STDERR
#   Any errors encountered while processing command line arguments or
#   while rendering files are written to the standard error.
#
# EXIT STATUS
#   0 If the script completes running successfully.
#   1 If there is a failure.
_main()
{
    _parse_arguments "$@"
    _build_site
    if [ "$_serve" = yes ]
    then
        _serve_site
    fi
}


# DESCRIPTION
#   Parse command line arguments passed to this script.
#
# OPERANDS
#   All command line arguments this script was invoked with.
#
# STDIN
#   Not used.
#
# STDOUT
#   Output of some command line arguments such as -h/--help,
#   -v/--version, etc. are written to the standard output.
#
# STDERR
#   Any errors encountered while processing command line arguments or
#   while rendering files are written to the standard error.
#
# EXIT STATUS
#   0 If the command line arguments are parsed and processed successfully.
#   1 If unknown command line option or argument is encountered.
_parse_arguments()
{
    while [ $# -gt 0 ]
    do
        case $1 in
            -h | --help)
                _show_help
                exit
                ;;
            -v | --version)
                _show_version
                exit
                ;;
            -s | --serve)
                _serve=yes
                shift
                ;;
            -*)
                quit Unknown option \""$1"\".
                ;;
            *)
                quit Surplus argument \""$1"\".
                ;;
        esac
    done
}


# DESCRIPTION
#   Show help.
#
# OPERANDS
#   None.
#
# STDIN
#   Not used.
#
# STDOUT
#   Usage details is written to the standard output.
#
# STDERR
#   Not used.
#
# EXIT STATUS
#   0
_show_help()
{
    cat <<eof
Usage: $NAME [-s] [-h] [-v]

Render static website. A site configuration script (default: ./site.sh)
is executed to render the website. It is the responsibility of the site
configuration script to call the oyster API to render the site source
files and write the rendered files into the site output directory.

Options:
  -s, --serve    Serve site with Python HTTP server.
  -h, --help     Display this help and exit.
  -v, --version  Display version information and exit.

Report bugs to <$SUPPORT_URL>.
eof
}


# DESCRIPTION
#   Show version and copyright.
#
# OPERANDS
#   None.
#
# STDIN
#   Not used.
#
# STDOUT
#   Version and copyright details are written to the standard output.
#
# STDERR
#   Not used.
#
# EXIT STATUS
#   0
_show_version()
{
    cat <<eof
Oyster $VERSION
$COPYRIGHT

This is free and open source software. You can use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of it,
under the terms of the MIT License.

This software is provided "AS IS", WITHOUT WARRANTY OF ANY KIND,
express or implied. See the MIT License for details.
eof
}


# DESCRIPTION
#   Terminate the script with an error message.
#
# OPERANDS
#   The strings to be written as error message to the standard error.
#   An arbitrary number of string arguments may be specified. All
#   arguments are joined into a single error message with spaces
#   introduced between arguments.
#
# STDIN
#   Not used.
#
# STDOUT
#   Not used.
#
# STDERR
#   Error message is written to the standard error.
#
# EXIT STATUS
#   1
quit()
{
    printf "%s: %s\n" "$NAME" "$*" >&2
    exit 1
}


# DESCRIPTION
#   Build website in current directory.
#
#   This function merely executes a site configuration script (./site.sh
#   by default). It is the responsibility of the site configuration
#   script to invoke the oyster API to build the site and write the
#   rendered files into a site output directory.
#
# OPERANDS
#   None.
#
# STDIN
#   Not used.
#
# STDOUT
#   Site configuration script's standard output is going to be written here.
#
# STDERR
#   Site configuration script's standard error is going to be written here.
#
# EXIT STATUS
#   0 On success.
#   1 On failure.
_build_site()
{
    . ./site.sh
}


# Commands to try to serve generated website.
#
# Each command is specified in a separate line. Each command is tried in
# the order specified until a command exits with status code 0.
_SERVE_COMMANDS="$(cat <<eof
python3 -c "import http.server" 2> /dev/null && python3 -m http.server
python -c "import http.server" 2> /dev/null && python -m http.server
python -c "import SimpleHTTPServer" 2> /dev/null && python -m SimpleHTTPServer
eof
)"


# DESCRIPTION
#   Serve generated website using Python's HTTP server.
#
#   This function assumes that the generated website is rendered within
#   _site directory relative to the current directory.
#
# OPERANDS
#   None.
#
# STDIN
#   Not used.
#
# STDOUT
#   Python HTTP server's standard output is going to be written here.
#
# STDERR
#   Python HTTP server's standard error is going to be written here.
#
# EXIT STATUS
#   0 On success.
#   1 On failure.
_serve_site()
{
    cd _site || quit Cannot find site directory.

    printf "%s\n" "$_SERVE_COMMANDS" | while read -r _command
    do
        printf "Trying %s ...\n" "$_command"
        eval "$_command" && break
    done
}


# Test files set _import=yes to prevent _main() from executing.
[ "$_import" = yes ] || _main "$@"
